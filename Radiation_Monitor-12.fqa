{"name":"Radiation Monitor","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_328"},"sections":{"items":[{"components":[{"name":"label","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"button","style":{"weight":"1.2"},"text":"Click to refresh reactor list next run","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_328"}}},"uiCallbacks":[{"callback":"buttonEvent","eventType":"onReleased","name":"button"}],"quickAppVariables":[{"name":"latitude","type":"string","value":"52.0810052"},{"name":"longitude","type":"string","value":"4.3066707"},{"name":"language","type":"string","value":"en"},{"name":"interval","type":"string","value":"3601"},{"name":"debugLevel","type":"string","value":"1"},{"name":"icon_refresh","type":"string","value":"1005"},{"name":"icon_green","type":"string","value":"1004"},{"name":"icon_yellow","type":"string","value":"1003"},{"name":"icon_red","type":"string","value":"1002"},{"name":"icon_error","type":"string","value":"1001"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"--[[ QUICKAPP RADIATION MONITOR\n\n\nThe Radiation Monitor collects radiation levels from all available stations around the world and shows 5 nearest stations to your location and one station with highest current readings and one station with the highest 24 hour average readings. The QuickApp uses the location (latitude and ongitude) of your Homecenter to measure the distance to the stations and to get the nearest stations. The bearings in degrees from your location to the stations is shown. Next to the measurements, the five nearest reactors are shown. The languages English, French, Polish and Duth are supported. \n\nThe main device shows the nearest measurement μSv/h. There are Child Devices for:\n- Nearest sensor 24h average μSv/h\n- 2nd, 3rd, 4th, 5th nearest sensor measurement with the 24 average in the log text\n- Nearest maximum measurement\n- Nearest maximum 24h average measurement\n\nThe nearest five reactors are retrieved once at startup of the QuickApp or at the next interval if you click on the button. \n\nRadioactive@Home is a Polish science project using the distributed computing capabilities of the BOINC platform. The main goal of the project is to create a free and continuously updated map of radiation levels available for everyone, by gathering information about gamma radiation using sensors connected to the computers of volunteers willing to participate in the project. Project is completely non-commercial, participating will be free of charge (excluding cost of detector) and the software will be licensed under the GNU General Public License (GPL).\n\nμSv/h: The sievert (symbol: Sv) is a unit in the International System of Units (SI) intended to represent the stochastic health risk of ionizing radiation.\n\nIn land navigation, a 'bearing' is ordinarily calculated in a clockwise direction starting from a reference direction of 0° and increasing to 359.9 degrees. Measured in this way, a bearing is referred to as an azimuth by the US Army but not by armies in other English speaking nations, which use the term bearing.\n\nThe human population is continuously exposed to ionizing radiation from several natural sources (cosmic and terrestrial contributions). For most individuals, exposure to natural sources exceeds that from all man-made (artificial) sources combined. The man-made sources arise from peaceful (e.g. medical use, energy generation, and associated fuel cycle facilities, radioisotope production, waste management) and military purposes (nuclear tests and their fallout or radioactive release, nuclear explosions).\n\nRadiation levels: \nGreen: Radiation up to 0.3 μSv/h\nYellow: Radiation between 0.3 and 0.8 μSv/h \nRed: Radiation above 0.8 μSv/h\n\n1.14 µSv/h - Shelter population\n5.7 µSv/h - Evacuation of population\n11.4 µSv/h - Issue Iodine tablets\n0.114 µSv/h - Max daily dose == 1 mSv/year\n\nReverse Geocoding by Nominatim\nReverse geocoding generates an address from a latitude and longitude. The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results. \n\nQuickApp code logics:\n- onInit() Initialise the QuickApp\n- getQuickAppVariables() Get all Quickapp Variables or create them\n- createVariables() Setup the global variables\n- setupChildDevices() Setup all child devices\n- loadMap() Get the webpage from http://radioactiveathome.org/map/ (loadMap() is the main loop of the QuickApp)\n- extractData() Extract the data from the webpage source-code (extract the reactor data once and the sensor data always)\n- geoDistance() Calculate the distance from the HC3 (QuickApp variables) lat/lon to the sensors lat/lon\n- Store the values of all sensors in a table and sort the table on distance\n- Run through the table to get the maximum measurement and maximum average measurements. If there are more than one, get the one that is the nearest-by\n- updateIcon() Set the icon (color) based on the sensor measurement\n- getCity() Get the cities, countries and calculate the geoBearing() for the seven selected sensors and five reactors from https://nominatim.openstreetmap.org/ and store them in a table\n- updateLabels() Update the labels (and assign the color dots to the sensor readings)\n- updateChildDevices() Update the Child Devices\n- updateProperties() Update the properties\n- Return to the main loop loadMap()\n\n\nLinks:\n- Radioactive@Home Map: http://radioactiveathome.org/map/\n- Status servers: http://radioactiveathome.org/boinc/server_status.php\n- Reverse geocoding: https://nominatim.org/release-docs/latest/api/Reverse/ licence:Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\n- Nominatim Usage Policy (aka Geocoding Policy): https://operations.osmfoundation.org/policies/nominatim/\n\nsensorData response line:\nL.marker([50.58, 8.69], {icon: icon_green}).bindPopup('Last sample: 0.08 uSv/h<br />Last contact: 2022-10-02 05:56:39<br/>24 hours average: 0.07 uSv/h<br />Sensor 43342<br/><a href=http://radioactiveathome.org/scripts/graph/drawweekdotted.php?hostid=43342>7 days plot</a><br/>Team: hidden<br />Nick: hidden').addTo(map);\nor\nL.marker([52.16, 4.5], {icon: icon_green}).bindPopup('Last sample: 0.11 uSv/h<br />Last contact: 2022-10-02 07:29:02<br/>24 hours average: 0.09 uSv/h<br /><a href=http://radioactiveathome.org/boinc/show_host_detail.php?hostid=43604>Details sensor 43604</a><br/><a href=http://radioactiveathome.org/boinc/results.php?hostid=43604>Work Units</a><br/><a href=http://radioactiveathome.org/scripts/graph/drawweekdotted.php?hostid=43604>7 days plot</a><br/>Team: AMD Users<br />Nick: Dirk Broer').addTo(map);\n\nreactorData response line:\nL.marker([22.5989, 114.544], {icon: icon_gold}).bindPopup('Name: Daya Bay 1 (Guangdong-1)<br>Capacity (Netto): 944 MW<br>Status: Operating<br>Start Year:1994<br>Owner: Guangdong Nuclear Power JVC (GNP JVC)').addTo(map);\n\nGeocity json response:\n{\"place_id\":298246927,\"licence\":\"Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\"osm_type\":\"relation\",\"osm_id\":88686,\"lat\":\"51.3155092\",\"lon\":\"6.2714171\",\"place_rank\":16,\"category\":\"boundary\",\"type\":\"administrative\",\"importance\":0.43630711984004145,\"addresstype\":\"city\",\"name\":\"Nettetal\",\"display_name\":\"Nettetal, Kreis Viersen, North Rhine-Westphalia, 41334, Germany\",\"address\":{\"town\":\"Nettetal\",\"county\":\"Kreis Viersen\",\"state\":\"North Rhine-Westphalia\",\"ISO3166-2-lvl4\":\"DE-NW\",\"postcode\":\"41334\",\"country\":\"Germany\",\"country_code\":\"de\"},\"boundingbox\":[\"51.2527722\",\"51.3659405\",\"6.1538213\",\"6.3265566\"]}\n\ngeoIDs Table json syntax:\n[{\"lon\":\"4.42\",\"lat\":\"50.81\"},{\"lon\":\"5.48\",\"lat\":\"50.96\"},{\"lon\":\"6.2\",\"lat\":\"51.32\"},{\"lon\":\"6.56\",\"lat\":\"51.34\"},{\"lon\":\"6.53\",\"lat\":\"50.83\"},{\"lon\":\"127.03\",\"lat\":\"37.53\"},{\"lon\":\"8.44\",\"lat\":\"45.96\"},{\"lon\":\"3.71867\",\"lat\":\"51.4311\"},{\"lon\":\"4.25658\",\"lat\":\"51.3249\"},{\"lon\":\"4.25919\",\"lat\":\"51.3227\"},{\"lon\":\"4.25708\",\"lat\":\"51.3249\"},{\"lon\":\"4.25868\",\"lat\":\"51.3227\"}]\n\nGeodata Table json syntax:\n[{\"bearing\":177,\"city\":\"Watermael-Boitsfort - Watermaal-Bosvoorde\",\"country\":\"Belgium\",\"number\":1},{\"bearing\":146,\"city\":\"Genk\",\"country\":\"Belgium\",\"number\":2},{\"bearing\":122,\"city\":\"Nettetal\",\"country\":\"Germany\",\"number\":3},{\"bearing\":117,\"city\":\"Krefeld\",\"country\":\"Germany\",\"number\":4},{\"bearing\":131,\"city\":\"Merzenich\",\"country\":\"Germany\",\"number\":5},{\"bearing\":43,\"city\":\"Seoul\",\"country\":\"South Korea\",\"number\":6},{\"bearing\":155,\"city\":\"Mergozzo\",\"country\":\"Italy\",\"number\":7},{\"bearing\":209,\"city\":\"\",\"country\":\"\",\"number\":8},{\"bearing\":182,\"city\":\"\",\"country\":\"\",\"number\":9},{\"bearing\":182,\"city\":\"\",\"country\":\"\",\"number\":10},{\"bearing\":182,\"city\":\"\",\"country\":\"\",\"number\":11},{\"bearing\":182,\"city\":\"\",\"country\":\"\",\"number\":12}]\n\nReverse API and parameters\nhttps://nominatim.openstreetmap.org/reverse?lat=<value>&lon=<value>&format=jsonv2&zoom=10&accept-language=<language>\n\nVariables (mandatory and created automatically): \n- latitude = Latitude of your location (Default is the latitude of your HC3)\n- longitude = Longitude of your location (Default is the longitude of your HC3)\n- language = Preferred language (default = en) (supported languages are French (fr), Polish (pl), Croatian (hr) and Dutch (nl))\n- interval = Interval in seconds to get the data from the Radioactive@Home website\n- debugLevel = Number (1=some, 2=few, 3=most, 4=all) (default = 1, debugLevel 4 is only recommended for solving difficult issues)\n- icon_refresh = User defined icon number for refresh status\n- icon_green = User defined icon number for values less than 0.3 μSv/h\n- icon_yellow = User defined icon number for values between 0.3 and 0.8 μSv/h \n- icon_red = User defined icon number for values greater than 0.8 μSv/h\n- icon_error = User defined icon number in case of an error gettng the data\n\n\nTODO:\n- Maybe: Show the city and country for the reactors ?\n\n\nVersion 1.2 (11th January 2023)\n- Added support for Croatian language thanks to @Sankotronic\n\n\nVersion 1.1 (9th January 2023)\n- Changed handling of negative values for dots and icons: if tonumber(num) >= 0 and tonumber(num) <= 0.3 then \n- Added a better translation for French (thanks to @fredoki)\n\nVersion 1.0 (5th November 2022)\n- Added the nearest five reactors to the labels with distance and bearing\n- Added a button to refresh the list of (five nearest) reactors\n- Added a warning at startup if the latitude or longitude differs from the setup of your HC3\n- Replaced the creation of the dots 🟢🟡🔴 to the labels, so no longer for all sensors\n- Added some extra notifications to the labels in case the website is down\n- Extended the http timeout a bit, to give the reverse geocoding some more time to respond\n- Added translations for new functions\n\n\nVersion 0.5 (29th October 2022)\n- Added translation to the Reverse API geocoding response (city and country)\n- Changed calculation of the bearings only for the 7 selected sensors, not all sensors\n- Optimized the code and added more structure by using multi file code (main, childs and i18n)\n\nVersion 0.4 (22nd October 2022)\n- Added six Child devices for the nearest sensor 24h average, 2nd, 3rd, 4th, 5th nearest sensor measurement, the nearest sensor maximum measurement and the nearest sensor maximum 24h average\n- Added icons based on sensor measurements to all Child Devices\n- Added translations for the labels and properties from English to French, Polish and Dutch\n- Limited the details of the response of the Reverse Geocoding with zoom=10 (address detail = city)\n\nVersion 0.3 (16th October 2022)\n- Added the City and Country also for maximum measurement and maximum average measurement\n- Added all debug information and set the debug levels\n- Optimised the code\n\nVersion 0.2 (15th October 2022)\n- Added the City and Country for all 5 sensors, not only the first one\n\nVersion 0.1 (15th October 2022)\n- Initial version\n\n\nNo editing of this code is needed --]]\n\n\nfunction QuickApp:buttonEvent() -- Refresh button event\n  if reactor_find then\n    reactor_find = false\n    self:updateView(\"button\", \"text\", translation[\"Refresh reactor list next interval\"])\n  else\n    reactor_find = true\n    self:updateView(\"button\", \"text\", translation[\"Reactor list will be refreshed next interval\"])\n  end\nend\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(self:getVariable(\"debugLevel\")) >= tonumber(level) then \n    self:debug(text)\n  end\nend\n\n\nlocal function updateIcon(num) -- Set the icon (colour) based on the sensor measurement\n  if tonumber(num) <= 0.3 then \n    return tonumber(quickApp:getVariable(\"icon_green\")) \n  elseif tonumber(num) <= 0.8 and tonumber(num) > 0.3 then\n    return tonumber(quickApp:getVariable(\"icon_yellow\")) \n  elseif tonumber(num) > 0.8 then\n    return tonumber(quickApp:getVariable(\"icon_red\")) \n  else\n    return tonumber(quickApp:getVariable(\"icon_error\")) \n  end\nend\n\n\nlocal function updateProperties() -- Update the properties and return to the main loop loadMap()\n  quickApp:logging(2,\"updateProperties() - Update the properties and return to the main loop loadMap()\")\n  quickApp:updateProperty(\"value\", tonumber(sensorData[1].sample)) \n  quickApp:updateProperty(\"unit\", \"μSv/h\")\n  quickApp:updateProperty(\"log\", sensorData[1].contact)\n  quickApp:updateProperty(\"deviceIcon\", updateIcon(sensorData[1].sample)) -- Set the icon (color) based on the sensor measurement\n  quickApp:logging(3, \"data: \" ..json.encode(data))\n  quickApp:logging(2,\"loadMap() - Return to loadMap() and wait for the interval of \" ..quickApp:getVariable(\"interval\")  ..\" seconds\")\nend\n\n\nlocal function updateChildDevices() -- Update Child Devices\n  quickApp:logging(2,\"updateChildDevices() - Update Child Devices\")\n  for id,child in pairs(quickApp.childDevices) do -- Update Child Devices\n    child:updateValue(data) \n  end\nend\n\n\nlocal function setColor(num) -- Set the color 🟢🟡🔴 based on the sensor measurement\n  if tonumber(num) >= 0 and tonumber(num) <= 0.3 then \n    return \"🟢\"\n  elseif tonumber(num) <= 0.8 and tonumber(num) > 0.3 then\n    return \"🟡\"\n  else\n    return \"🔴\"\n  end\nend\n\n\nlocal function updateLabels() -- Update the labels\n  quickApp:logging(2,\"updateLabels() - Update the labels\")\n  table.sort(geoData,function(a,b) return tonumber(a.number) < tonumber(b.number) end)\n  quickApp:logging(3,\"geoData: \" ..json.encode(geoData))\n  local labelText = \"\"\n  for i=1,5 do \n    labelText = labelText ..translation[\"Sensor\"] ..\": \" ..sensorData[i].sensor ..\" (\" ..(geoData[i].city or \"\") ..\" \" ..(geoData[i].country or \"\") ..\")\" ..\"\\n\"\n    labelText = labelText ..\"Lat: \" ..sensorData[i].lat ..\" Lon: \" ..sensorData[i].lon ..\" (\" ..sensorData[i].distance ..\" km \" ..geoData[i].bearing ..\"°)\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[i].sample) ..\" \" ..translation[\"Radiation\"] ..\": \" ..sensorData[i].sample ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[i].average) ..\" \" ..translation[\"24hour average\"] ..\": \" ..sensorData[i].average ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..translation[\"Date\"] ..\": \" ..sensorData[i].contact ..\"\\n\\n\"\n  end\n  \n  if data.sampleMaxID == data.averageMaxID then -- In case sensors maximum measurement and maximum average measurement are the same\n    labelText = labelText ..translation[\"Nearest maximum measurement and maximum average location\"] ..\": \" \n  else\n    labelText = labelText ..translation[\"Nearest maximum measurement location\"] ..\": \" \n  end\n\n    labelText = labelText..sensorData[data.sampleMaxID].sensor ..\"\\n\"\n    labelText = labelText ..(geoData[6].city or \"\") ..\" \" ..(geoData[6].country or \"\") ..\"\\n\"\n    labelText = labelText ..\"Lat: \" ..sensorData[data.sampleMaxID].lat ..\" Lon: \" ..sensorData[data.sampleMaxID].lon ..\" (\" ..sensorData[data.sampleMaxID].distance ..\" km \" ..geoData[6].bearing ..\"°)\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[data.sampleMaxID].sample) ..\" \" ..translation[\"Radiation\"] ..\": \" ..sensorData[data.sampleMaxID].sample ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[data.sampleMaxID].average) ..\" \" ..translation[\"24hour average\"] ..\": \" ..sensorData[data.sampleMaxID].average ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..translation[\"Date\"] ..\": \" ..sensorData[data.sampleMaxID].contact ..\"\\n\\n\"\n\n  if data.sampleMaxID ~= data.averageMaxID then -- In case sensors maximum measurement and maximum average aren't the same\n    labelText = labelText ..translation[\"Nearest maximum average location\"] ..\": \" ..sensorData[data.averageMaxID].sensor ..\"\\n\"\n    labelText = labelText ..(geoData[7].city or \"\") ..\" \" ..(geoData[7].country or \"\") ..\"\\n\"\n    labelText = labelText ..\"Lat: \" ..sensorData[data.averageMaxID].lat ..\" Lon: \" ..sensorData[data.averageMaxID].lon ..\" (\" ..sensorData[data.averageMaxID].distance ..\" km \" ..geoData[7].bearing ..\"°)\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[data.averageMaxID].sample) ..\" \" ..translation[\"Radiation\"] ..\": \" ..sensorData[data.averageMaxID].sample ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..setColor(sensorData[data.averageMaxID].average) ..\" \" ..translation[\"24hour average\"] ..\": \" ..sensorData[data.averageMaxID].average ..\" μSv/h\" ..\"\\n\"\n    labelText = labelText ..translation[\"Date\"] ..\": \" ..sensorData[data.averageMaxID].contact ..\"\\n\\n\"\n  end\n\n  labelText = labelText ..translation[\"Total sensors\"] ..\": \" ..data.sensorTotal ..\"\\n\\n\"\n  \n  for i=1,5 do \n    labelText = labelText ..\"☢️ \" ..reactorData[i].owner ..\"\\n\"\n    labelText = labelText ..reactorData[i].reactor ..\" Lat: \" ..reactorData[i].lat ..\" Lon: \" ..reactorData[i].lon ..\" (\" ..reactorData[i].distance ..\" km \"  ..geoData[i+7].bearing ..\"°)\"..\"\\n\"\n    labelText = labelText ..translation[\"Capacity\"] ..\": \" ..reactorData[i].capacity ..\" \" ..translation[\"Status\"] ..\": \" ..reactorData[i].status ..\" Start: \" ..reactorData[i].startyear ..\"\\n\\n\"\n  end\n\n  quickApp:updateView(\"label\", \"text\", labelText)\n  quickApp:updateView(\"button\", \"text\", translation[\"Refresh reactor list next interval\"]) -- Update the button label to the default value\n  quickApp:logging(2,\"Label: \" ..labelText)\nend\n\n\nlocal function geoBearing(lat1, lon1, lat2, lon2) -- Calculate the bearing from the HC3 (QuickApp variables) lat/lon to the sensors lat/lon\n  if lat1 == nil or lon1 == nil or lat2 == nil or lon2 == nil then\n    return 0\n  end\n  local deltaLon = lon1 - lon2\n  local x = math.cos(math.rad(lat1)) * math.sin(math.rad(deltaLon))\n  local y = math.cos(math.rad(lat2)) * math.sin(math.rad(lat1)) - math.sin(math.rad(lat2)) * math.cos(math.rad(lat1)) * math.cos(math.rad(deltaLon))\n  local bearing = (math.deg(math.atan2(x,y)) + 360.0) % 360.0\n  return tonumber(string.format(\"%.0f\", bearing)) \nend\n\n\nlocal function getCity() -- Get the cities and countries and calculate the bearings for the seven selected sensors from https://nominatim.openstreetmap.org/ and store them in a table\n  quickApp:logging(2,\"getCity() - Get the cities and countries and calculate the bearings for the seven selected sensors from https://nominatim.openstreetmap.org/ and store them in a table\")\n  local address = \"\"\n  local geoIDs = {}\n  geoData = {} -- Clear geoData every loop \n  for i=1,5 do --  Insert the first 5 sensors\n    table.insert(geoIDs,i,{lat=sensorData[i].lat,lon=sensorData[i].lon}) -- Insert the 5 nearest sensors\n  end\n  table.insert(geoIDs,6,{lat=sensorData[data.sampleMaxID].lat,lon=sensorData[data.sampleMaxID].lon}) -- Insert the (nearest) sensor with the maximum measurement\n  table.insert(geoIDs,7,{lat=sensorData[data.averageMaxID].lat,lon=sensorData[data.averageMaxID].lon}) -- Insert the (nearest) sensor with the maximum average\n  for i=1,5 do -- Insert the first 5 reactors\n    table.insert(geoIDs,i+7,{lat=reactorData[i].lat,lon=reactorData[i].lon}) -- Insert the 5 nearest reactors\n  end  \n  quickApp:logging(3,\"geoIDs: \" ..json.encode(geoIDs))\n\n  --for i=1,12 do\n  for i=1,7 do \n    quickApp:logging(3, \"Get City and Country \" ..i ..\" with: \" ..geoIDs[i].lat ..\" \" ..geoIDs[i].lon)\n    address = \"https://nominatim.openstreetmap.org/reverse?lat=\" ..geoIDs[i].lat ..\"&lon=\" ..geoIDs[i].lon ..\"&format=jsonv2&zoom=10&accept-language=\" ..string.lower(quickApp:getVariable(\"language\"))\n    http:request(address,{options = {headers = headers, checkCertificate = true,  method = \"GET\",},\n      success = function(response)\n        if (response.status < 200 or response.status >= 300) then\n          quickApp:warning(\"Wrong status '\" .. response.status .. \"' in getCity response!\")\n          table.insert(geoData,{number=i,city=\"\", country=\"\", bearing=0}) -- Insert empty city and country if nothing is found or bad response\n        else\n          quickApp:logging(3,\"response.data geoCity: \" ..response.data)\n          local jsonTable = {}\n          jsonTable = json.decode(response.data)\n          table.insert(geoData,{number=i, city=(jsonTable.address.city or jsonTable.address.village or jsonTable.address.town), country=jsonTable.address.country, bearing=geoBearing(geoIDs[i].lat, geoIDs[i].lon, tonumber(quickApp:getVariable(\"latitude\")), tonumber(quickApp:getVariable(\"longitude\")))})\n        end\n      end,\n      error = function(error)\n      table.insert(geoData,{number=i,city=\"\", country=\"\", bearing=0}) -- Insert empty city and country if nothing is found or bad response\n      quickApp:error(\"Connection error: \" ..json.encode(error))\n    end})\n  end\n  for i=8,12 do -- Insert only the bearing for the 5 reactors\n    table.insert(geoData,{number=i, city=\"\", country=\"\", bearing=geoBearing(geoIDs[i].lat, geoIDs[i].lon, tonumber(quickApp:getVariable(\"latitude\")), tonumber(quickApp:getVariable(\"longitude\")))})\n  end\n  fibaro.setTimeout(10*1000, function() updateLabels() end) -- Update the labels\n  fibaro.setTimeout(10*1000, function() updateChildDevices() end) -- Update the Child Devices\n  fibaro.setTimeout(10*1000, function() updateProperties() end) -- Update the properties\nend\n\n\nlocal function geoDistance(lat1, lon1, lat2, lon2) -- Calculate the distance from the HC3 (QuickApp variables) lat/lon to the sensors lat/lon\n  if lat1 == nil or lon1 == nil or lat2 == nil or lon2 == nil then\n    return 0\n  end\n  local R = 6372.797560856 -- Earth's in meters\n  local sin_dlat = math.sin((math.rad(lat2 - lat1)) / 2)\n  local sin_dlon = math.sin((math.rad(lon2 - lon1)) / 2)\n  local a = sin_dlat * sin_dlat + math.cos(math.rad(lat1)) * math.cos(math.rad(lat2)) * sin_dlon * sin_dlon\n  local distance = R * (2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))) -- To get miles, use 3963 as the constant (equator again)\n  return tonumber(string.format(\"%.0f\", distance))\nend\n\n\nlocal function extractData(pageSource) -- Extract the data from the webpage source-code\n  quickApp:logging(2,\"extractData() - Extract the data from the webpage source-code\")\n  quickApp:logging(4,\"pageSource: \" ..pageSource)\n  \n  sensorData = {} -- Get the sensor data from the page source\n  data.sensorTotal = 0\n  local start_find = string.find(pageSource, \"// show a marker on the map\") + 114 -- Look for the markers on the map\n  local end_find = string.find(pageSource, \"icon: icon_gold\") - 30\n  local extract = pageSource:sub(start_find, end_find) -- Extract the sensor readings from the page source\n  quickApp:logging(4,\"extract sensors: \" ..extract)\n\n  if start_find ~= nil then \n    local sensor, lat, lon, sample, average, contact, city, country, distance = \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\n    local timezone = os.difftime(os.time(), os.time(os.date(\"!*t\",os.time())))/3600 -- Check timezone and daylight saving time\n    if os.date(\"*t\").isdst then -- Check daylight saving time \n      timezone = timezone + 1\n    end\n    local pattern = \"(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)\" -- Convert time of measurement to local timezone\n    local runyear, runmonth, runday, runhour, runminute, runseconds = \"\", \"\", \"\", \"\", \"\", \"\"\n    local convertedTimestamp = \"\"\n\n    local extract_line = \"\"\n    extract = extract:gsub(\"<br/>\", \" \") -- Get rid of html tags\n    extract = extract:gsub(\"<br />\", \" \")\n    extract = extract:gsub(\"</a>\", \" \")\n    extract = extract:gsub(\"<a href=\", \" \")\n\n    while extract:len() > 100 do\n      end_find = string.find(extract, \";\") - 1\n      extract_line = extract:sub(1, end_find) -- Get one line for one sensor\n      quickApp:logging(4,\"extract_line sensor: \" ..extract_line)\n\n      start_find = string.find(extract_line, \"ensor\") + 6 -- Sensor 40389 http or Details sensor 34532 http (without \"S\" because upper and lower case) \n      sensor = extract_line:sub(start_find, start_find + 5) -- Maximum length sensor ID is 5\n      sensor = sensor:gsub(\"%a\", \"\") -- Delete non digital characters, if there are any\n      sensor = sensor:gsub(\" \", \"\") -- Delete spaces, if there are any\n\n      start_find = string.find(extract_line, \"L.marker\") + 10 -- L.marker([50.83, 8.94\n      end_find = string.find(extract_line, \",\") - 1\n      lat = extract_line:sub(start_find, end_find)\n\n      start_find = string.find(extract_line, \",\") + 2 -- 50.83, 8.94], {\n      end_find = string.find(extract_line, \"]\") - 1\n      lon = extract_line:sub(start_find, end_find)\n\n      start_find = string.find(extract_line, \"sample:\") + 8 -- Last sample: 0.15 uSv/h\n      end_find = string.find(extract_line, \"uSv\") - 2\n      sample = extract_line:sub(start_find, end_find)\n\n      start_find = string.find(extract_line, \"average:\") + 9 -- 24 hours average: 0.14 uSv/h\n      average = extract_line:sub(start_find, start_find + 3)\n      average = average:gsub(\"%a\", \"\") -- Delete non digital characters, if there are any\n\n      start_find = string.find(extract_line, \"contact:\") + 9 -- Last contact: 2022-10-02 07:17:16 24 hours average\n      end_find = string.find(extract_line, \"hours\") - 4\n      contact = extract_line:sub(start_find, end_find)\n      \n      runyear, runmonth, runday, runhour, runminute, runseconds = contact:match(pattern)\n      convertedTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})\n      contact = os.date(\"%d-%m-%Y %X\", convertedTimestamp +(timezone*3600))\n\n      distance = geoDistance(lat, lon, tonumber(quickApp:getVariable(\"latitude\")), tonumber(quickApp:getVariable(\"longitude\"))) -- Calculate the distance from the HC3 (QuickApp variables) lat/lon to the sensors lat/lon\n\n      table.insert(sensorData,{sensor=sensor,lat=lat,lon=lon,sample=sample,average=average,contact=contact,distance=distance}) -- Store the values of all sensors in a table and sort the table on distance\n\n      end_find = string.find(extract, \";\") + 2\n      if end_find == nil then\n        return\n      else \n        data.sensorTotal = data.sensorTotal + 1\n        extract = extract:sub(end_find) -- Erase the sensor reading line\n      end\n    end\n\n    table.sort(sensorData,function(a,b) return tonumber(a.distance) < tonumber(b.distance) end) --  Sort the sensor table on distance\n    quickApp:logging(3,\"sensorData: \" ..json.encode(sensorData))\n\n    -- Run through the sensor table to get the maximum measurement and maximum average measurements. If there are more than one, get the one that is the nearest-by\n    data.sampleMaxID, data.averageMaxID = 0, 0\n    local sampleMax, averageMax = 0, 0 \n    for n in pairs(sensorData or {}) do \n      if tonumber(sensorData[n].sample) > tonumber(sampleMax) then\n        sampleMax = sensorData[n].sample\n        data.sampleMaxID = n\n      end\n      if tonumber(sensorData[n].average) > tonumber(averageMax) then\n        averageMax = sensorData[n].average\n        data.averageMaxID = n\n      end   \n    end\n\n    -- Set the icon (color) based on the sensor measurement\n    data.icon1 = updateIcon(sensorData[1].average)\n    data.icon2 = updateIcon(sensorData[2].sample)\n    data.icon3 = updateIcon(sensorData[3].sample)\n    data.icon4 = updateIcon(sensorData[4].sample)\n    data.icon5 = updateIcon(sensorData[5].sample)\n    data.icon6 = updateIcon(sensorData[data.sampleMaxID].sample)\n    data.icon7 = updateIcon(sensorData[data.averageMaxID].average)\n\n    if reactor_find then -- Get the reactor data only once\n      reactorData = {} -- Get the reactor data from the page source\n      start_find = string.find(pageSource, \"icon: icon_gold\") - 50 -- Look for the first icon_gold in the page source\n      end_find = string.find(pageSource, \"var marker\") - 12\n      extract = pageSource:sub(start_find, end_find) -- Extract the reactor data from the page source\n      start_find = string.find(extract, \";\") + 1\n      extract = extract:sub(start_find) -- Clear the first part\n      quickApp:logging(4,\"extract reactors: \" ..extract)\n\n      local reactor, capacity, status, startyear, owner = \"\", \"\", \"\", \"\", \"\"\n      lat, lon, city, country, distance = \"\", \"\", \"\", \"\", \"\"\n      extract_line = \"\" -- Clear extract_line\n      extract = extract:gsub(\"<br>\", \" \")\n\n      while extract:len() > 200 do\n        end_find = string.find(extract, \";\") - 1\n        extract_line = extract:sub(1, end_find) -- Get one line for one reactor\n        quickApp:logging(4,\"extract_line reactor: \" ..extract_line)\n\n        start_find = string.find(extract_line, \"Name: \") + 6 -- Name: St. Laurent-B1 Capacity\n        end_find = string.find(extract_line, \"Capacity\") - 1\n        reactor = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \"L.marker\") + 10 -- L.marker([44.3297, 4.73318\n        end_find = string.find(extract_line, \",\") - 1\n        lat = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \",\") + 2 -- 44.3297, 4.73318], {\n        end_find = string.find(extract_line, \"]\") - 1\n        lon = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \"): \") + 3 -- Capacity (Netto): 915 MW Status\n        end_find = string.find(extract_line, \"Status\") - 1 \n        capacity = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \"Status: \") + 8 -- Status: Operating Start Year\n        end_find = string.find(extract_line, \"Start Year\") - 1\n        status = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \"Start Year: \") + 12 -- Start Year: 1981 Owner\n        end_find = string.find(extract_line, \"Owner\") - 1\n        startyear = extract_line:sub(start_find, end_find)\n\n        start_find = string.find(extract_line, \"Owner: \") + 7 -- Owner: Electricite de France (EdF)').addTo(map)\n        end_find = string.find(extract_line, \"addTo\") - 4\n        owner = extract_line:sub(start_find, end_find)\n\n        distance = geoDistance(lat, lon, tonumber(quickApp:getVariable(\"latitude\")), tonumber(quickApp:getVariable(\"longitude\"))) -- Calculate the distance from the HC3 (QuickApp variables) lat/lon to the reactors lat/lon\n\n        -- Store the values of all reactors in a table and sort the table on distance\n        table.insert(reactorData,{reactor=reactor,lat=lat,lon=lon,capacity=capacity,status=status,startyear=startyear,owner=owner,distance=distance}) \n\n        end_find = string.find(extract, \";\") + 2\n        if end_find == nil then\n          return\n        else \n          extract = extract:sub(end_find) -- Erase the reactor reading line\n        end\n      end\n      table.sort(reactorData,function(a,b) return tonumber(a.distance) < tonumber(b.distance) end) --  Sort the reactor table on distance\n      quickApp:logging(3,\"reactorData: \" ..json.encode(reactorData))\n      reactor_find = false\n    end\n\n  else\n    quickApp:warning(\"No measurements found\")\n      quickApp:updateProperty(\"deviceIcon\", tonumber(quickApp:getVariable(\"icon_error\"))) -- Set the icon (color) to error\n    return\n  end\nend\n\n\nfunction QuickApp:loadMap() -- Get the webpage from http://radioactiveathome.org/map/ (This is the main loop of the QuickApp)\n  self:logging(2,\"loadMap() - Get the webpage from http://radioactiveathome.org/map/ (This is the main loop of the QuickApp)\")\n  local address = \"http://radioactiveathome.org/map/\"\n  http:request(address,{options = {headers = headers, method = \"GET\",}, success = function(response)\n   if (response.status < 200 or response.status >= 300) then\n      self:warning(\"Wrong status '\" .. response.status .. \"' in loadMap response!\")\n    else\n      local pageSource = response.data\n      self:updateProperty(\"deviceIcon\", tonumber(self:getVariable(\"icon_refresh\"))) -- Set the icon (color) to refresh\n      extractData(pageSource) --Extract the data from the webpage source-code\n      getCity() -- Get the cities and countries for the seven selected sensors from https://nominatim.openstreetmap.org/ and store them in a table\n    end\n  end,\n  error = function(error)\n    self:error(\"Connection error: \" ..json.encode(error))\n    self:updateView(\"label\", \"text\", \"Connection error: \" ..json.encode(error))\n    self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n    self:updateProperty(\"deviceIcon\", tonumber(self:getVariable(\"icon_error\"))) -- Set the icon (color) to error\n  end\n  })\n  fibaro.setTimeout(tonumber(self:getVariable(\"interval\"))*1000, function() self:loadMap() end)\nend\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\nfunction QuickApp:setupChildDevices() -- Setup all child devices\n  self:logging(2,\"setupChildDevices() - Setup all child devices\")\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all Child Devices\n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs == 0 then -- If no Child Devices, create them\n    local initChildData = { \n      {className=\"sensor1\", name=\"24h average\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor2\", name=\"Sensor 2\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor3\", name=\"Sensor 3\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor4\", name=\"Sensor 4\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor5\", name=\"Sensor 5\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor6\", name=\"Max sample\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"sensor7\", name=\"Max 24 average\", type=\"com.fibaro.multilevelSensor\", value=0},\n    }\n    for _,c in ipairs(initChildData) do\n      local child = self:createChildDevice(\n        {name = c.name, type=c.type, value=c.value, initialInterfaces = {}, }, \n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className)  -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:createVariables() -- Setup the global variables\n  self:logging(2,\"createVariables() - Setup the global variables\")\n  sensorData, geoData, data = {}, {}, {}\n  data.sensorTotal, data.sampleMaxID, data.averageMaxID = 0, 0, 0\n  data.icon1, data.icon2, data.icon3, data.icon4, data.icon5, data.icon6, data.icon7 = tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\")), tonumber(self:getVariable(\"icon_refresh\"))\n  translation = i18n:translation(string.lower(self:getVariable(\"language\"))) -- Initialise the translation\n  reactor_find = true\n  self:updateProperty(\"deviceIcon\", tonumber(self:getVariable(\"icon_refresh\"))) -- Set the icon (color) to refresh\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Get all Quickapp Variables or create them\n  local latitude = tonumber(self:getVariable(\"latitude\"))\n  local longitude = tonumber(self:getVariable(\"longitude\"))\n  local language = string.lower(self:getVariable(\"language\"))\n  local interval = self:getVariable(\"interval\") \n  local debugLevel = self:getVariable(\"debugLevel\") \n  local icon_refresh = self:getVariable(\"icon_refresh\") \n  local icon_green = self:getVariable(\"icon_green\") \n  local icon_yellow = self:getVariable(\"icon_yellow\") \n  local icon_red = self:getVariable(\"icon_red\") \n  local icon_error = self:getVariable(\"icon_error\") \n  \n  if latitude == 0 or latitude == nil then \n    latitude = tostring(api.get(\"/settings/location\")[\"latitude\"]) or 40.866667 -- Or centre of the earth\n    self:setVariable(\"latitude\", latitude)\n    self:trace(\"Added QuickApp variable latitude with HC3 value \" ..latitude)\n  elseif latitude ~= api.get(\"/settings/location\")[\"latitude\"] then\n    self:warning(\"The latitude in the QuickApp variable (\" ..latitude ..\") differs from the latitude setting of your HC3 (\" ..api.get(\"/settings/location\")[\"latitude\"]..\")\")\n  end  \n  if longitude == 0 or longitude == nil then\n    longitude = tostring(api.get(\"/settings/location\")[\"longitude\"]) or 34.566667 -- Or centre of the earth\n    self:setVariable(\"longitude\", longitude)\n    self:trace(\"Added QuickApp variable longitude with HC3 value \" ..longitude)\n  elseif longitude ~= api.get(\"/settings/location\")[\"longitude\"] then\n    self:warning(\"The longitude in the QuickApp variable (\" ..longitude ..\") differs from the longitude setting of your HC3 (\" ..api.get(\"/settings/location\")[\"longitude\"]..\")\")\n  end\n  if language == \"\" or language == nil or type(i18n:translation(string.lower(self:getVariable(\"language\")))) ~= \"table\" then\n    language = \"en\" \n    self:setVariable(\"language\",language)\n    self:trace(\"Added QuickApp variable language\")\n  end\n  if interval == \"\" or interval == nil then\n    interval = \"3601\" \n    self:setVariable(\"interval\",interval)\n    self:trace(\"Added QuickApp variable interval\")\n  end\n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" \n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n  end\n  if icon_refresh == \"\" or icon_refresh == nil then \n    icon_refresh = \"1144\" \n    self:setVariable(\"icon_refresh\",icon_refresh)\n    self:trace(\"Added QuickApp variable icon_refresh, please check the icon number\")\n  end\n  if icon_green == \"\" or icon_green == nil then \n    icon_green = \"1145\" \n    self:setVariable(\"icon_green\",icon_green)\n    self:trace(\"Added QuickApp variable icon_green, please check the icon number\")\n  end\n  if icon_yellow == \"\" or icon_yellow == nil then \n    icon_yellow = \"1146\" \n    self:setVariable(\"icon_yellow\",icon_yellow)\n    self:trace(\"Added QuickApp variable icon_yellow, please check the icon number\")\n    icon_yellow = tonumber(icon_yellow)\n  end\n  if icon_red == \"\" or icon_red == nil then \n    icon_red = \"1147\"\n    self:setVariable(\"icon_red\",icon_red)\n    self:trace(\"Added QuickApp variable icon_red, please check the icon number\")\n  end\n  if icon_error == \"\" or icon_error == nil then \n    icon_error = \"1148\"\n    self:setVariable(\"icon_error\",icon_error)\n    self:trace(\"Added QuickApp variable icon_error, please check the icon number\")\n  end\n  self:logging(2,\"getQuickAppVariables() - Get all Quickapp Variables or create them\") \nend\n\n\nfunction QuickApp:onInit() --Initialise the QuickApp\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit() - Initialise the QuickApp\")  \n  \n  if not api.get(\"/devices/\"..self.id).enabled then\n    self:warning(\"Device\", fibaro.getName(plugin.mainDeviceId), \"is disabled\")\n    return\n  end\n  \n  self:getQuickAppVariables() -- Get all Quickapp Variables or create them\n  self:createVariables() -- Setup the global variables\n  self:setupChildDevices() -- Setup all child devices\n  \n  http = net.HTTPClient({timeout=10*1000})\n  self:loadMap() -- This is also the main loop\nend\n\n-- EOF "},{"name":"i18n","isMain":false,"isOpen":true,"content":"-- Radiaton Monitor i18n Translations\n\n\nclass \"i18n\"\nfunction i18n:translation(language)\n  translation = {\n    en = {\n      [\"Radiation\"] = \"Radiation\", \n      [\"24h average\"] = \"24h average\", \n      [\"24hour average\"] = \"24hour average\", \n      [\"Sensor\"] = \"Sensor\", \n      [\"Total sensors\"] = \"Total sensors\", \n      [\"Date\"] = \"Date\", \n      [\"Nearest maximum measurement and maximum average location\"] = \"Nearest maximum measurement and maximum average location\", \n      [\"Nearest maximum average location\"] = \"Nearest maximum average location\",\n      [\"Nearest maximum measurement location\"] = \"Nearest maximum measurement location\", \n      [\"Max 24h average\"] = \"Max 24h average\", \n      [\"Max measurement\"] = \"Max measurement\", \n      [\"Average\"] = \"Average\", \n      [\"Capacity\"] = \"Capacity\", \n      [\"Refresh reactor list next interval\"] = \"Refresh reactor list next interval\", \n      [\"Reactor list will be refreshed next interval\"] = \"Reactor list will be refreshed next interval\", \n      [\"Status\"] = \"Status\"}, \n    nl = {\n      [\"Radiation\"] = \"Straling\", \n      [\"24h average\"] = \"24u gemiddelde\", \n      [\"24hour average\"] = \"24-uurs gemiddelde\", \n      [\"Sensor\"] = \"Sensor\", \n      [\"Total sensors\"] = \"Aantal sensoren\", \n      [\"Date\"] = \"Datum\", \n      [\"Nearest maximum measurement and maximum average location\"] = \"Dichtstbijzijnde maximale meting en gemiddelde locatie\", \n      [\"Nearest maximum average location\"] = \"Dichtstbijzijnde maximale gemiddelde locatie\",\n      [\"Nearest maximum measurement location\"] = \"Dichtstbijzijnde maximale meting locatie\", \n      [\"Max 24h average\"] = \"Max 24u gemidddelde\", \n      [\"Max measurement\"] = \"Max meting\", \n      [\"Average\"] = \"Gemiddeld\", \n      [\"Capacity\"] = \"Capaciteit\", \n      [\"Refresh reactor list next interval\"] = \"Reaktorlijst vernieuwen volgende interval\", \n      [\"Reactor list will be refreshed next interval\"] = \"Reactorlijst wordt volgende interval vernieuwd\", \n      [\"Status\"] = \"Status\"}, \n    fr = {\n      [\"Radiation\"] = \"Radiation\", \n      [\"24h average\"] = \"Moyenne sur 24h\", \n      [\"24hour average\"] = \"Moyenne sur 24 heures\", \n      [\"Sensor\"] = \"Capteur\", \n      [\"Total sensors\"] = \"Nombre de Capteurs\", \n      [\"Date\"] = \"Date\", \n      [\"Nearest maximum measurement and maximum average location\"] = \"Emplacement le plus proche de la mesure maximale et de la moyenne maximale\", \n      [\"Nearest maximum average location\"] = \"Emplacement maximum moyen le plus proche\",\n      [\"Nearest maximum measurement location\"] = \"Emplacement de la mesure maximale la plus proche\",\n      [\"Max 24h average\"] = \"Moyenne maximale 24h\", \n      [\"Max measurement\"] = \"Mesure maximale\", \n      [\"Average\"] = \"Moyen\", \n      [\"Capacity\"] = \"Capacité\", \n      [\"Refresh reactor list next interval\"] = \"Rafraîchir la liste des réacteurs au prochain intervalle\", \n      [\"Reactor list will be refreshed next interval\"] = \"La liste des réacteurs sera actualisée au prochain intervalle\", \n      [\"Status\"] = \"Statut\"},\n    pl = {\n      [\"Radiation\"] = \"Promieniowanie\", \n      [\"24h average\"] = \"średnia dobowa\", \n      [\"24hour average\"] = \"średnia z 24 godzin\", \n      [\"Sensor\"] = \"Czujnik\", \n      [\"Total sensors\"] = \"Całkowita liczba czujników\", \n      [\"Date\"] = \"Data\", \n      [\"Nearest maximum measurement and maximum average location\"] = \"Najbliższa maksymalna próbka i średnia witryna\", \n      [\"Nearest maximum average location\"] = \"Najbliższa maksymalna średnia witryna\",\n      [\"Nearest maximum measurement location\"] = \"Najbliższa maksymalna przykładowa witryna\",\n      [\"Max 24h average\"] = \"Max średnia 24h\", \n      [\"Max measurement\"] = \"Maksymalny pomiar\", \n      [\"Average\"] = \"Przeciętny\",\n      [\"Capacity\"] = \"Pojemność\", \n      [\"Refresh reactor list next interval\"] = \"Odśwież listę reaktorów następny interwał\", \n      [\"Reactor list will be refreshed next interval\"] = \"Lista reaktorów zostanie odświeżona w następnym interwale\", \n      [\"Status\"] = \"Status\"},\n    hr = {\n      [\"Radiation\"] = \"Radijacija\", \n      [\"24h average\"] = \"24h prosjek\", \n      [\"24hour average\"] = \"24sata prosjek\", \n      [\"Sensor\"] = \"Senzor\", \n      [\"Total sensors\"] = \"Ukupno senzora\", \n      [\"Date\"] = \"Datum\", \n      [\"Nearest maximum measurement and maximum average location\"] = \"Najbliže maksimalno mjerenje i mjesto najvišeg prosjeka\", \n      [\"Nearest maximum average location\"] = \"Najbliže mjesto s najvišim prosjekom\",\n      [\"Nearest maximum measurement location\"] = \"Najbliže mjesto s najvišim mjerenjem\", \n      [\"Max 24h average\"] = \"Max 24h prosjek\", \n      [\"Max measurement\"] = \"Max mjerenje\", \n      [\"Average\"] = \"Prosjek\", \n      [\"Capacity\"] = \"Kapacitet\", \n      [\"Refresh reactor list next interval\"] = \"Osvježi popis reaktora sljedeći interval\", \n      [\"Reactor list will be refreshed next interval\"] = \"Popis reaktora bit će osvježen sljedeći interval\", \n      [\"Status\"] = \"Stanje\"},\n    } \n  translation = translation[language] -- Shorten the table to only the current translation\n  return translation\nend\n\n-- EOF "},{"name":"childs","isMain":false,"isOpen":true,"content":"-- Radiation Monitor Classes Child Devices\n\nclass 'sensor1'(QuickAppChild)\nfunction sensor1:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor1:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[1].average))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"24h average\"])\n  self:setName(geoData[1].city)\n  self:updateProperty(\"deviceIcon\", data.icon1)\nend\n\n\nclass 'sensor2'(QuickAppChild)\nfunction sensor2:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor2:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[2].sample))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Average\"] ..\" \" ..sensorData[2].average ..\" μSv/h\")\n  self:setName(geoData[2].city)\n  self:updateProperty(\"deviceIcon\", data.icon2)\nend\n\n\nclass 'sensor3'(QuickAppChild)\nfunction sensor3:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor3:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[3].sample))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Average\"] ..\" \" ..sensorData[3].average ..\" μSv/h\")\n  self:setName(geoData[3].city)\n  self:updateProperty(\"deviceIcon\", data.icon3)\nend\n\n\nclass 'sensor4'(QuickAppChild)\nfunction sensor4:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor4:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[4].sample))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Average\"] ..\" \" ..sensorData[4].average ..\" μSv/h\")\n  self:setName(geoData[4].city)\n  self:updateProperty(\"deviceIcon\", data.icon4)\nend\n\n\nclass 'sensor5'(QuickAppChild)\nfunction sensor5:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor5:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[5].sample))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Average\"] ..\" \" ..sensorData[5].average ..\" μSv/h\")\n  self:setName(geoData[5].city)\n  self:updateProperty(\"deviceIcon\", data.icon5)\nend\n\n\nclass 'sensor6'(QuickAppChild)\nfunction sensor6:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor6:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[data.sampleMaxID].sample))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Max measurement\"])\n  self:setName(geoData[6].city)\n  self:updateProperty(\"deviceIcon\", data.icon6)\nend\n\n\nclass 'sensor7'(QuickAppChild)\nfunction sensor7:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction sensor7:updateValue(data) \n  self:updateProperty(\"value\", tonumber(sensorData[data.averageMaxID].average))\n  self:updateProperty(\"unit\", \"μSv/h\")\n  self:updateProperty(\"log\", translation[\"Max 24h average\"])\n  self:setName(geoData[7].city)\n  self:updateProperty(\"deviceIcon\", data.icon7)\nend\n\n-- EOF "}]}